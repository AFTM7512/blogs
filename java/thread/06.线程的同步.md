## 线程同步机制
> 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个`对象的等待池`形成队列，等待前面线程使用完毕，下一个线程才能使用。

* 形成条件：`队列 + 锁`；

### 并发
> 同一个对象被多个线程同时操作。
```java
// 模拟多个人购票，最终会出现多人购买同一张票，甚至出现票的总数为负数的情况
public class UnsafeBuyTacket {
    public static void main(String[] args) {
        Station station = new Station();

        Thread student = new Thread(station, "student");
        student.start();
        Thread worker = new Thread(station, "worker");
        worker.start();
        Thread scalper = new Thread(station, "scalper");
        scalper.start();
    }
}

class Station implements Runnable {
    private int ticketNums = 10; // 票的总数
    private boolean flag = false; //
    @Override
    public void run() {
        while (ticketNums >= 0) {
            try {
                // 放大异常情况的概率
                Thread.sleep(500);

                System.out.println(Thread.currentThread().getName() + "买了第" + ticketNums-- + "张票");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### `Synchronized`
* `synchronized` 锁的一定是变化的量；
* 由于我们可以通过 `private` 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 `synchronized` 关键字，它包括两种方法：`synchronized`方法和 `synchronized`块；
  * `synchronized` 关键字：锁的是当前类也就是 `this`;
  * `synchronized`块：锁的是传入的对象；
* `synchronized`方法控制对`对象`的访问，每个对象对应一把锁，每个 `synchronized` 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才能释放锁，后面被阻塞的线程才能获得这个锁，继续执行。
* 若将一个大的方法申明为 `synchronized` 将会影响效率。

### `synchronized` 关键字
```java
public class SyncDemo1 implements Runnable {
    private int ticketNums = 10;

    @Override
    public void run() {
        this.buyTicket();
    }

    // 买票方法是主体，将买票编程同步
    public synchronized void buyTicket() {
        // while 循环，只要有票，就支持购买
        while (ticketNums > 0) {
            try {
                Thread.sleep(300);
                System.out.println(Thread.currentThread().getName() + "买了第" + this.ticketNums-- +"张票");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 调用
public class Application {
    public static void main(String[] args) {
        SyncDemo1 syncDemo1 = new SyncDemo1();

        Thread student = new Thread(syncDemo1, "student");
        student.start();
        Thread worker = new Thread(syncDemo1, "worker");
        worker.start();
        Thread scalper = new Thread(syncDemo1, "scalper");
        scalper.start();
    }
}
```

### `synchronized`块
> `synchronized (Obj) {}`，将需要对应改变的数据，放到块中，同时传入需要修改的对象。
```java
public class BanK implements Runnable {
    Account account;
    int new_money;

    public BanK(Account account,int new_money) {
        this.account = account;
        this.new_money = new_money;
    }

    @Override
    public void run() {
        synchronized (this.account) {
            if (this.account.count >= this.new_money) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }


                // 将要修改的对象，放到 synchronized 块中
                this.account.count -= this.new_money;
                System.out.println(Thread.currentThread().getName() + "取了" + this.new_money);
                System.out.println(this.account.name + "还剩" + this.account.count);
            } else {
                System.out.println("余额不足");
            }
        }
    }
}

// 账户
class Account {
    int count;
    String name;
    public Account(int count, String name) {
        this.count = count;
        this.name = name;
    }
}


public class Application {
    public static void main(String[] args) {
        Account account = new Account(100, "buy house");

        new Thread(new bank(account, 100), "youWife").start();
        new Thread(new bank(account, 50), "you").start();
    }
}
```