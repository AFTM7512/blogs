## 死锁
> 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情况。某一个同步块同时拥有`两个以上对象的锁`时，就可能会发生`死锁`的问题。

```java
public class Deadlock {
    public static void main(String[] args) {
        /*
          两个人都持有一份资源，同时都需要等待对方释放资源后，再去执行下一步操作
        */
        Makeup xh = new Makeup(0,"小红");
        xh.start();
        Makeup xl = new Makeup(1,"小绿");
        xl.start();
    }
}

/**
 * 现在有两份资源
 *  1. 一份镜子
 *  2. 一份口红
 * */
class Mirror {}
class Lipstick {}

// 争取资源的主体
class Makeup extends Thread {
    private static Mirror mirror = new Mirror();
    private static Lipstick lipstick = new Lipstick();
    private int chiose;
    private String girlName;

    public Makeup(int chiose, String girlName) {
        this.chiose = chiose;
        this.girlName = girlName;
    }

    @Override
    public void run() {
        if (this.chiose == 0) {
            synchronized (this.mirror) {
                System.out.println(this.girlName + "获取了镜子");
                try {
                    Thread.sleep(1000); // 一秒后获取口红
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (this.lipstick) {
                    System.out.println(this.girlName + "获取了口红");
                }
            }
        } else {
            synchronized (this.lipstick) {
                System.out.println(this.girlName + "获取了口红");
                try {
                    Thread.sleep(2000); // 两秒后获取镜子
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (this.mirror) {
                    System.out.println(this.girlName + "获取了镜子");
                }
            }
        }
    }
}

```

## lock 锁（显式锁）
* 从 `JDK5.0`开始，`Java`提供了更强大的线程同步机制 => 通过显示定义同步锁对象来实现同步，同步锁使用 `Lock` 对象充当；
* `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源的独占访问，每次只能有一个线程对 `Lock` 对象加锁，线程开始访问共享资源之前应先获得 `Lock` 对象
* `ReentrantLock` 类实现了 `Lock`，它拥有与 `synchrinized` 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 `ReentrantLock`，可以显式枷锁，释放锁。